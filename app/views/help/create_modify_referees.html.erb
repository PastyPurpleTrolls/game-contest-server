<br>
<ol class="breadcrumb">
  <li><%= link_to 'Home', root_path %></li>
  <li><%= link_to 'Help', help_path %></li>
  <li class="active">Create, Modify, or Delete Referees</li>
</ol>

<div class="row">
  <div class="display-container">
    <h1>Create, Modify, or Delete Referees</h1>
    <p>
      Referees are the central system for controlling games between players. These pieces of software connect with
      players via sockets, report game results, and enforce rules.
    </p>
  </div>
</div>

<div class="row">
  <div class="display-container">
    <h2 class="help-l2-header"><b>Design</b></h2>
    <p>
      Referees may be uploaded as a single file, or in a tar/zip file that contains
      the referee and a makefile.
    </p><br>

    <h3><b>Single-file Referees</b></h3>
    <p>
      Referees should be implemented to support four flags from the game manager.
    </p>
    <ul>
      <li>
        <code>-p</code>: (string) UNIX domain socket path in which the manager is listening for a connection. The
        referee must connect and send a UNIX domain socket path for the players to connect to. If the referee does not
        respond with a UNIX domain socket path within three seconds of being started, the manager will declare a
        timeout.
      </li>
      <li>
        <code>-n</code>: (int) The number of players that will connect to the referee.
      </li>
      <li>
        <code>-r</code>: (int) The number of rounds that the referee should run between the players. If your referee
        does not support rounds, you can ignore the value of this flag.
      </li>
      <li>
        <code>-t</code>: (int) Maximum amount of time allowed per match, in seconds. The game manager will enforce this
        time.
      </li>
    </ul><br>

    <h3><b>Makefile Referees</b></h3>
    <p>
      The makefile should implement two actions: run, and contest. For example, a Python referee might have a makefile
      like this:
    </p>
    <pre><code class="makefile">.PHONY: run contest manager clean

include player.mk

manager:
    nc -lU $(path)

run: test_referee.py
    ./test_referee.py -p $(path) -n $(num_players) -r $(num_rounds) -t $(max_time)

contest: $(PLAYER)
    ./$(PLAYER).py -p $(path) -n '$(name)'</code></pre>
    <p>
      The run rule is called to start the referee.  When the referee is called through the Makefile, the manager will
      provide four flags:
    </p>
    <ul>
      <li>
        <code>path</code>: (string) UNIX domain socket path in which the manager is listening for a connection. The
        referee must connect and send a UNIX domain socket path for the players to connect to. If the referee does not
        respond with a UNIX domain socket path within three seconds of being started, the manager will declare a
        timeout.
      </li>
      <li>
        <code>num_players</code>: (int) The number of players that will connect to the referee.
      </li>
      <li>
        <code>num_rounds</code>: (int) The number of rounds that the referee should run between the players. If your
        referee does not support rounds, you can ignore the value of this flag.
      </li>
      <li>
        <code>max_time</code>: (int) Maximum amount of time allowed per match, in seconds. The game manager will enforce
        this time.
      </li>
    </ul>
    <p>
      The contest rule is called to start the player.  When the player is called through the Makefile, the manager will
      provide two flags:
    </p>
    <ul>
      <li>
        <code>name</code>: The name of the player as registered on the contest server. The player will be required to
        communicate this name to the referee so the referee can report the results to the manager properly. The player
        should not assume a particular name to report to the referee because the manager may choose to give a different
        name to the player for each match for disambiguation purposes.
      </li>
      <li>
        <code>path</code>: (string) UNIX domain socket path in which the manager is listening for a connection. All
        communication with the referee will be done via this path; there is no other mechanism for communication between
        the referee or any other player.
      </li>
    </ul>
    <h2>TODO: Further examples</h2>
  </div>
</div>

<div class="row">
  <div class="display-container">
    <h2 class="help-l2-header"><b>Protocol</b></h2>
    <p>
      Referees must communicate with the game manager via a UNIX domain socket. Three main pieces of information are
      expected: a player TCP port number, results of rounds, final results of match (if rounds are supported). The
      referee must also send the moves made in each round.
    </p>
    <p>
      For efficiency in the client visualizer, the referee should periodically should send the game state to the
      manager. We have chosen a value of 10 moves for the initial games prototyped with the system.
    </p>
    <p>
      Commands are sent as key:value pairs. The first <code>:</code> in the command is seen as a special character and
      represents the end of a command name. Everything that follows is interpreted as the value. Pipes <code>|</code>
      represent separation between values that should be parsed.
    </p>
    <p>
      Do <b>not</b> use <code>|</code> for any purpose except as a delimiter to represent lists in the protocol. It
      should not be used in game state representations.
    </p><br>

    <h3><b>Defined Keywords</b></h3>
    <ul>
      <li>
        <code>path</code>: (string) UNIX domain socket path in which the manager is listening for a connection. This
        needs to be sent within the first three seconds of being started.
      </li>
      <li>
        <code>match</code>: Values: <code>start</code>, <code>end</code>. Tell the manager to expect information about
        the match.
      </li>
      <li>
        <code>round</code>: Pipe separated double. <code>start</code> or <code>end</code>. Round start can also contain
        any data about the round.
      </li>
      <li>
        <code>move</code>: Human readable description of the move as well as any round data needed by the visualizer.
        Data should be formatted in JSON to make parsing easier.
      </li>
      <li>
        <code>gamestate</code>: Implementation dependant value. Sent periodically to represent the current state of the
        game. To ease parsing in the browser, please use JSON.
      </li>
      <li>
        <code>roundresult</code>: Sent directly after <code>round:end</code>. Pipe separated tuple with player name,
        result, and score. Score is implementation dependent. Result can only be <code>Win</code>, <code>Loss</code>,
        and <code>Tie</code>.
      </li>
      <li>
        <code>matchresult</code>: Sent directly after <code>match:end</code>. Pipe separated tuple with player name,
        result, and rounds won.
      </li>
    </ul><br>

    <h3><b>Example communication</b></h3>
    <pre><code class="nohighlight">path:/tmp/guess-w-referee
match:start
round:start|{}
move:description|movedata
gamestate:{}
round:end
roundresult:playername|result|score
roundresult:playername|result|score
match:end
matchresult:playername|result|roundswon
matchresult:playername|result|roundswon</code></pre>
  </div>
</div>

<div class="row">
  <div class="display-container">
    <h2 class="help-l2-header"><b>Replay Plugin</b></h2>
    <p>
      Every referee should be uploaded along with a replay plugin. Replays are an important piece of the learning
      experience and allow students to figure out what their player did during competition matches.
    </p>
    <p>
      Replay plugins must be uploaded in a compressed file containing <code>script.js</code> and any other assets
      required by the plugin. Allowed compressed file formats are <code>.tar</code> and <code>.zip</code>. The
      compressed file must be a flat directory structure, any folders uploaded will not be available for use.
    </p><br>

    <h3><b>Logs</b></h3>
    <p>
      Log files are generated from data sent by the referee over the course of a round. This log is loaded and made
      available to the Replay plugin on load.
    </p>
    <p>
      Moves always have a description and data. Move data can be sent in any format by the game referee, but JSON is
      preferred to allow for easy parsing. Optionally, the game referee can send game state after a move to provide
      information as to what the game looked like after the move was completed. If provided, <code>gamestate</code> will
      be listed as an additional key:value pair in the move object.
    </p>

    <p>Example:</p>
    <pre><code class="js">{
    "results": {
        "Player2": {
            "result": "Win",
            "score": "1"
        },
        "Player1": {
            "result": "Loss",
            "score": "0"
        }
    },
    "moves": [{
        "description": "Player2 plays w",
        "data": "['Player2', 'w']"
    }],
    "info": "0"
}</code></pre><br>

    <h3><b>Example Plugin</b></h3>
    <p>
      The GitHub repository contains an
      <a href="https://github.com/PastyPurpleTrolls/game-contest-server/tree/master/examples/guess-w/python/guess_w_referee.py"
         class="link">
        example referee</a>,
      <a href="https://github.com/PastyPurpleTrolls/game-contest-server/tree/master/examples/guess-w/python/talk_to_referee.py"
         class="link">
        player-includes file</a>,
      <a href="https://github.com/PastyPurpleTrolls/game-contest-server/tree/master/examples/guess-w/script.js"
         class="link">
        replay plugin</a>, and
      <a href="https://github.com/PastyPurpleTrolls/game-contest-server/tree/master/examples/guess-w/python/sometimes_win_player.py"
         class="link">
        player</a>.
    </p><br>

    <h3><b>API</b></h3>
    <p>
      Every plugin must define <code>script.js</code>. This script defines the logic for generating gamestates and
      rendering the game to the screen.
    </p>
    <p>
      The Replay API is defined in
      <a href="https://github.com/PastyPurpleTrolls/test/blob/master/app/assets/javascripts/round.js">round.js</a>.
      Please refer the commented source for any questions on exact functionality.
      <a href="http://pixijs.com">PIXI.js</a> runs the rendering code for displaying replays. Please refer to its
      <a href="https://pixijs.github.io/docs/index.html">documentation</a> when writing rendering code.
    </p>

    <h3><b>Replay API</b></h3>
    <p>
      The Replay API is available through the global Replay object. Plugins should modify the prototype
      (<code>Replay.prototype</code>) to define functionality and attributes.
    </p>
    <p>
      Three settings are available to Replay plugins.
    </p>

    <pre><code class="js">// Width and height of the renderer
Replay.prototype.rendererWidth = 750;
Replay.prototype.rendererHeight = 750;

// Time between moves (in seconds)
Replay.prototype.playIncrement = 1;</code></pre>

    <ul>
      <li class="space-between">
        <p>
          <code>Replay.prototype.initPlugin()</code>
        </p>
        <p>
          Called immediately after initialization of the Replay object. This hook should be used for any logic that
          needs to be precomputed.
        </p>
        <p>
          <em>Note: the round log will not be available when this function is called.</em>
        </p>
      </li>
      <li class="space-between">
        <p>
          <code>Replay.prototype.generateGamestate()</code>
        </p>
        <p>
          Called whenever a new move is loaded. Any logic that is required in order to generate a gamestate should be
          executed in this method.
        </p>
        <p>Several attributes are available on the Round object to provide move data. Use
          <code>self.parseJSON(string)</code> to safely parse move data.
        </p>
        <ul>
          <li>
            <code>self.round</code>: Contains the parsed contents of the round log JSON file.
          </li>
          <li>
            <code>self.moveNumber</code>: is available in order to access the current move. It is important to note that
            moveNumber is not 0 indexed. A value of 1 would translate to index 0 in the moves array.
          </li>
        </ul>
      </li>
      <li class="space-between">
        <p>
          <code>Replay.prototype.render()</code>
        </p>
        <p>
          Renders the current move gamestate to the WebGL context. Called immediately after
          <code>self.generateGamestate()</code>
        </p>
      </li>
      <li class="space-between">
        <p>
          <code>Replay.prototype.rendererLoaded()</code>
        </p>
        <p>
          Called directly after the PIXI renderer has been defined and added to the page. Should be used to change any
          options (like background color) on the renderer.
        </p>
      </li>
      <li class="space-between">
        <p>
          <code>Replay.prototype.loadTextures()</code>
        </p>
        <p>
          Load any required textures into the PIXI context. Call
          <code>self.addTexture(name, url)</code> to add a new texture. The URL will be relative
          to the assets folder that <code>script.js</code> is located in. Textures are added to
          the <code>self.textures</code> object.
        </p>
      </li>
      <li class="space-between">
        <p>
          <code>Replay.prototype.loadSprites()</code>
        </p>
        <p>
          Load any PIXI sprites on initial load. Creating new sprites in the <code>render()</code> method should be
          avoided if possible.
        </p>
        <p>
          New sprites should be defined on <code>self.sprites</code> as a new key:value pair. Sprites can be added as a
          group (in an array) if that is convenient. For example:
        </p>
        <pre><code class="js">
self.sprites["spriteName"] = new PIXI.Sprite(self.textures["textureName"]);

self.sprites["pieces"] = [];

for (var i = 0; i < 10; i++) {
    self.sprites["pieces"][i] = new PIXI.Sprite(self.textures["textureName"]);
}
        </code></pre>
      </li>
      <li class="space-between">
        <p>
          <code>Replay.copy(src)</code>
        </p>
        <p>
          Helper function to deep copy objects (useful when calculating a new gamestate for each move)
        </p>
      </li>
    </ul>
  </div>
</div>